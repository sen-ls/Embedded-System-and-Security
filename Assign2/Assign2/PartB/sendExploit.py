#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import serial
import argparse
import base64
import struct

DEVPATH = "/dev"
TTYPREFIX = "ttyACM"
SIZE_LENGTH = 3
NONCE_LENGTH = 24
TAG_LENGTH = 32
B64URL_CHARS = b"-_"
MAXSIZE = 65535

class NonceError(Exception):
  def __init__(self, message):
    self.message = message

def producePacket(exploit, nonce):
  text = base64.urlsafe_b64encode(exploit.read(MAXSIZE))
  header = base64.urlsafe_b64encode(struct.pack("I", len(text))[:SIZE_LENGTH]) + nonce.encode("ascii")
  return bytes(b'\x01' + header + b'\x02' + text + b'\x03')

#def base64len(length):
#  return ceil(length/3)*4
#
#def answerLength(packet):
#  # packet is 1 + (3+24)/3*4 + 1 + text/3*4 + 1 byte long
#  # answer is 1 +       (32+text)      /3*4 + 1 byte long
#  # Round up so we read enough bytes even with worst case padding
#  return len(packet)-(1+base64len(SIZE_LENGTH+NONCE_LENGTH)+1+1)+(1+base64len(TAG_LENGTH)+1)

def sendPacket(ttys, packet):
  for tty in ttys:
    with serial.Serial(tty, timeout=1, writeTimeout=1) as ctt:
      ctt.reset_input_buffer()
      ctt.reset_output_buffer()
      print("Writing to {:s}: {:s}".format(tty, repr(packet)))
      try:
        ctt.write(packet)
      except serial.SerialTimeoutException:
        print("The device at {:s} does not respond, skipping it. (Write Timeout)".format(tty))
        continue
      waitReceive = True
      while waitReceive:
        try:
          sys.stdout.write(ctt.read(MAXSIZE).decode("ascii"))
        except serial.SerialTimeoutException:
          waitReceive = False
        if ctt.in_waiting <= 0:
          waitReceive = False
      sys.stdout.write("\n")

if __name__=='__main__':
  parser = argparse.ArgumentParser(description="A tool to packetize exploits and send them "
             +"to the XMC board during Assignment 2 of the course Embedded Systems and Security")
  parser.add_argument('exploit', type=argparse.FileType('rb'), help="Name of the file that contains"
                                                                   +" the exploit to be sent")
  parser.add_argument('--device', type=str, nargs='*',
                                  default=[os.path.join(DEVPATH,tty) for tty in os.listdir(DEVPATH)\
                                                                      if tty.startswith(TTYPREFIX)],
                                  help="Name of the tty to send over. If omitted, it will send to"
                                      +" all available ttyACM*.")
  parser.add_argument('--nonce', type=str,
                                 default=base64.urlsafe_b64encode(os.urandom(NONCE_LENGTH)).decode("ascii"),
                                 help="The nonce to use, encoded as base64url. If omitted, it will"
                                     +" be generated automatically.")
  args = parser.parse_args()

  try:
    n = base64.b64decode(args.nonce, B64URL_CHARS, validate=True)
  except binascii.Error:
    raise NonceError("Provided nonce contains illegal characters or is incorrectly padded")
  if len(n) != NONCE_LENGTH:
    raise NonceError("Provided nonce has incorrect length")

  p = producePacket(args.exploit, args.nonce)

  sendPacket(args.device, p)
